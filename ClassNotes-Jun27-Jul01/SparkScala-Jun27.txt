
  Agenda (Spark using Scala)
  --------------------------
   -> Scala Refresher
   -> Spark - Basics & Architecture
   -> Spark Core API
	-> RDD Transformations and Actions
	-> Spark Shared Variable
        -> Spark-Submit
   -> Spark SQL
	-> DataFrame Operations
	-> Integration with MySQL & Hive
	-> SQL Optimizations & Tuning
   -> Spark Streaming
	-> DStreams API (introduction)
	-> Structured Streaming


  Materials
  ---------
	=> PDF Presentations
	=> Code Modules
	=> Class Notes
	=> Github: https://github.com/ykanakaraju/sparkscala

 
  Scala
  ===== 
     	=> SCAlable LAnguage
	
	=> Statically Typed Language
		-> Data type os a variable is fixed at compile time.
		-> Can not change the data type. 
		
	=> Scala is comiler-based language

   	=> Scala is a multi-paradigm Programming Lang.
		-> Scala is an OOP Lang
		-> Scala is Functional Programming

	=> Scala has type inference

	=> Scala is a Pure object oriented language. 
               -> Scala does not have primitives and operators

        => Scala mutables and immutables
		var => Multables: Can change  
		val => Immutable: Can not change once assigned.

		Scala prefers "Immutables"

		val i = 10
		i = 20  // Invalid
	
		var i = 10
		i = 20  // Valid
			

     Scala Blocks
     ------------
	=> A block is a set of statements and expressions enclosed in  { }
	=> A block has a return value 
		-> The return value of the block is the value of the last statement/expression that
		   is executed in that block.
	
		
     Scala "Unit" => is a Class whose object represent "no value".
		 => Printed as ()


     Scala Flow Control Constructs
     -----------------------------

	=> if .. else if .. else
        => match .. case

	
	=> if .. else consutruct returns a value
	   The return value is the value if the last executed statement of the executed block. 

		val x = 100
    		val y = 150
    		var z = 0
    
    		z = if ( x > y )  x - y  else if (x < y) y - x else x   

        => match..case consutruct returns a value
	   The return value is the value if the last executed statement of the executed block. 

		x match {
        		case 10 => z = 10
        		case 20 => z = 20
        		case a if (a % 2 == 0) => { z = 10 }
        		case _ => { z = -1 }        
    		} 

		z = x match {
       			case 10 => 10
        		case 20 => 20
        		case a if (a % 2 == 0) => {
          			val i = 10
          			val j = 20
          			i + j + a
        		}
        		case _ => -1        
    		}

    Loop Constructs
    ---------------

	-> while
	-> do .. while
	-> foreach

		<Iterable>.foreach(<function>)

		"scala".foreach( x => println("x = " + x) ) 
	-> for

	for loop: 
	---------

		for ( i <- 1 to 10 ) {
         		println(s"i: $i, j: $j")
      		}

		for ( i <- 1 to 10; j <- 1 to 10 by 2) {
         		println(s"i: $i, j: $j")
      		}

		for ( i <- 1 to 10 if (i%2 != 0); j <- 1 to 10 by 2 ) {
         		println(s"i: $i, j: $j")
      		}

		for ( i <- 1 to 10 if (i%2 != 0); j <- 1 to 10 by 2 if (i != j) ) {
         		println(s"i: $i, j: $j")
      		}

		for comprehension
		-----------------
		val v1 = for ( i <- 1 to 10 if (i%2 != 0)) yield(i*10)      
     		println( v1 )   // Returns Vector(10, 30, 50, 70, 90)


    Range class
    -----------
	Range(start, end, step) => generates Int values from start to (end-1) with a step

	Range(1, 10, 2) => 1,3,5,7,9
	Range(20, 0, -3) => 20, 17, 14, 11, 8, 5, 2
	Range(1, 10, -1) => empty
	Range(1, 10) => 1,2,3,4,5,6,,7,8,9 (default step is 1)

	1 to 10 	 => 1,2,3,4,5,6,7,8,9,10  (Range.inclusive)
	1 until 10 	 => 1,2,3,4,5,6,7,8,9     (Range)

	0 to 10 by 2	 => 0,2,4,6,8,10
	0 until 10 by 2  => 0,2,4,6,8

 
   Interpolators
   -------------

    s interpolator : s"x = $x, y = ${y + 10}"

    f interpolator : s interpolator + interpolate formatting characters 
		     f"x = $x%2.2f, y = $y%1.3f"

    raw interpolator : s interpolator + escape the escape characters
		  raw"x = $x%2.2f\ny = $y%1.3f"



    Exception Handling
    -------------------

	try {
		// some code that throws an exception
	}
	catch {
	    case e: FileNotFoundException => {
		   println( e.getMessage ) 
		}

	    case e: ArrayIndexOutOfBounds => { ... }
            case e: Exception => { ... }
	    case _ => { ... }
	}
	finally {
	     // some code that is always executed
	}


   Getting started with Scala
   ==========================

     1. Using your vLab

	  -> You connect to Windows server
	  -> Double Click on the Oracle VM Virtualbox icon
		-> Launch the Ubuntu VM
		   -> Open a terminal
		   -> Type "spark-shell"
		   -> Launch "Scala-IDE" for eclipse

     2. Setting up Scala development environment on your personal machine.

	 2.1 Scala IDE

	  	-> Make sure you have Java 8 (JDK 1.8.x)
		  (run "java -version" command at command prompt)
          	-> Download Scala IDE for Eclispe from http://scala-ide.org/download/sdk.html

         2.2 IntelliJ
		-> https://docs.scala-lang.org/getting-started/index.html

		=> Community Edition: https://www.jetbrains.com/idea/download/#section=windows
		=> Installing Scala Plug-in: https://www.jetbrains.com/help/idea/managing-plugins.html

		=> Working with Scala on IntelliJ:
		   -> https://docs.scala-lang.org/getting-started/intellij-track/building-a-scala-project-with-intellij-and-sbt.html


     3. Using Databricks Community Edition Free account
 
		Sign-up: https://databricks.com/try-databricks
	  	Login: https://community.cloud.databricks.com/login.html



     4. Using Online Scala Editors: https://scastie.scala-lang.org/pEBYc5VMT02wAGaDrfLnyw



    Scala Class Heirarchy
    ----------------------

       Any   => AnyVal => Int, Long, Double, Boolean, CHar, Unit
	     => AnyRef => String, List, Tuple, All other classes..


    Collections
    -----------
	=> Array	  -> Mutable & Fixed Length
	   ArrayBuffer	  -> Mutable & Variable Length

	=> Seq  : Ordered Collections
		  Elements can be invoked using an index.

		 => IndexedSeq : Optimized for random-access of data
			-> Range, Vector

		 => LinearSeq : Optimized for sequential-access (loops)
				These are linked lists
			-> List, Queue, Stream

	=> Set  : Unordered collection of unique objects

	=> Map : Is a collection of (Key, Value) pair


   Reading from File
   -----------------

	val lines = scala.io.Source.fromFile( <filePath> ).getLines.toSeq


    Option[U]
    ---------

	=> Represents a object which may or may not have a value.
	=> Returns Some[U] if value is present
		   None if value is not present
	

    Methods
    --------
	=> A method is a executable code block

	=> Methods can be called using positional parameter
	=> Methods can be called using named parameter
	=> methods can have multiple parameter lists
	=> Methods parameter can have one variable-lengh arguments and it has to be last argument.
	=> Method parameters can have default values.
	=> Methods can be called recusivly (recursive method)


    Procedures
    ----------
	=> Are like mathods, but they always return Unit


	def box(s: String) {
       	     val border = "-" * s.length() + "----"       
       	     println( border + "\n| " + s + " |\n" + border )
    	}


    Functions
    ---------
	=> Function are treated as literals
		Function literal: (a: Int, b: Int) => { a + b }
	=> Functions are anonymous by nature
	=> Function can be assigned to a variable

        Function literal				Type
	----------------------------------------------------------------
	(a: Int, b: Int) => a + b			(Int, Int) => Int
	(s: String) => s.toUpperCase			String => String
	(a: Int, b: String) => b * a			(Int, String) => String
	() =>  "Windows 10"				() => String
	(s: String) => print(s)				String => Unit
	(a: (Int, Int), b: Int) => (a._1+b, a._2+b)     ((Int, Int), Int) => (Int, Int)

	=> A function can be passed as a parameter to a method or function
	=> A block can return a function as a final value.
	=> A method / function can return a function as an output.

	def compute(op: String) = {
            op match {
         	case "+" => (a : Int, b: Int) => a + b
          	case "-" => (a : Int, b: Int) => a - b
          	case "*" => (a : Int, b: Int) => a * b
          	case _ => (a : Int, b: Int) => a % b
             }
     	}


   Higher Order Functions (HOF)
   ----------------------
    A HOF is a method or function that take a function as a parameter or returns a function as a return value.

    1. map			P: U => V
   				Transforms each object of the input collection to a different object by appying 
				the function
				input: N object, output: N object 

		 l1.map(x => x > 8)
		 lines.map( s => s.split(" ") )

    2. filter			P: U => Boolean 
				Only those objects for which the function returns true will be in the output. 
				input: N object, output: <= N object 

		lines.filter(x => x.split(" ").length > 8)

    3. reduceLeft, reduceRight	P: (U, U) => U 
				Reduces the entire collection to one final value of the same time by iterativly
				applying the function.

		List(3,2,4,3,5,6).reduceLeft( (x, y) => x - y )
    		3,2,4,3,5,6 => 1,4,3,5,6 => -3,3,5,6 => -6,5,6 => -11,6 => -17

		List(3,2,4,3,5,6).reduceRight( (x, y) => x - y )
		3,2,4,3,5,6 => 3,2,4,3,-1 => 3,2,4,4 => 3,2,0 => 3,2 => 1		

		List[U].reduceLeft( (U,U) => U ) => U

		l2.reduceLeft( (x, y) => ( ((if (x._1 > y._1) x._1 else y._1), (if (x._2 > y._2) x._2 else y._2)) ))


    4. flatMap			P: U => GenTraversableOnce[V]  (fn output should be a collection object)
				flatMap flattens the function output to constituent elements.
				input: N object, output: >= N object 

				List[U].flatMap( U -> List[V] ) => List[V]

				val words = lines.flatMap(x => x.split(" "))


   5. sortWith			P: binary sorting function
				Elements of th collection are sorted based on the binary sorting function.  
				input: N object, output: N object 

			words.sortWith( (x, y) => x(0) < y(0) )

   6. groupBy			P: U => V
				Elements of the input collection are grouped based on the function output.
				Returns a Map object where:
					key : unique function output
					value: Collection containing elements that produced the key

			l2.groupBy(x => x._2)
			words.groupBy(x => x).toList.map(x => (x._1, x._2.length)).sortWith((x, y) => x._1 < y._1)


   7. foldLeft & foldRight	=> reduces the entire collection to a type that is different that the type of objects

			Two parameters as param-list
			
			1. zero-value : starting value of the type of output you want as output
			2. Sequence Function : is a function that iterativly merges all the objects of the 
			   collection with the zero-value. 

			List[U].foldLeft( (V, U) => V )  => V
	
				
		l1.foldRight( (0,0) )( (v, z) => (z._1 + v, z._2 + 1) )



  Assignments 
  ============

	=> Write a method to print the first N numbers in the fibonnaci series
	   function: printFib	
		printFib(7) => 1, 1, 2, 3, 5, 8, 13

        => Write a method to print the first N prime numbers		
	   function: printPrimes
		printPrimes(7) => 2, 3, 5, 7, 11, 13, 17








   